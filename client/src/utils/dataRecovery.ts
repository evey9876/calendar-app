import { openDB, type DBSchema, type IDBPDatabase } from 'idb';
import { Event, EventType, insertEventSchema } from '@shared/schema';
import { apiRequest } from '@/lib/queryClient';

interface CalendarDB extends DBSchema {
  events: {
    key: string;
    value: Event;
    indexes: {
      'by-date': string;
      'by-type': string;
    };
  };
}

// Legacy event format that might exist in old storage
interface LegacyEvent {
  id?: string;
  title: string;
  type?: string | EventType;
  date: string | Date;
  endDate?: string | Date;
  startTime?: string;
  endTime?: string;
  notes?: string;
  createdAt?: string | Date;
  updatedAt?: string | Date;
  // Old field names that might exist
  eventType?: string;
  description?: string;
  time?: string;
  duration?: string;
}

// Recovery progress reporting
interface RecoveryProgress {
  stage: 'scanning' | 'normalizing' | 'deduplicating' | 'importing' | 'complete' | 'error';
  found: number;
  processed: number;
  imported: number;
  duplicates: number;
  errors: string[];
}

// Recovery state tracking
const RECOVERY_STATE_KEY = 'calendar-recovery-state';
interface RecoveryState {
  lastRunDate: string;
  importedFingerprints: string[];
  completedSources: string[];
}

// Database names to check for IndexedDB data
const INDEXEDDB_NAMES = [
  'calendar-db',
  'calendar',
  'events-db',
  'calendar-app',
  'event-storage',
  'replit-calendar'
];

// LocalStorage keys to check for data
const LOCALSTORAGE_KEYS = [
  'calendar-events',
  'events',
  'calendar-data',
  'stored-events',
  'backup-events',
  'event-backup'
];

// Create a fingerprint for an event to detect duplicates
function createEventFingerprint(event: LegacyEvent): string {
  const title = (event.title || '').toLowerCase().trim();
  const date = normalizeDate(event.date);
  const type = normalizeEventType(event.type);
  const startTime = event.startTime || '';
  
  return `${title}-${date}-${type}-${startTime}`;
}

// Normalize legacy date formats
function normalizeDate(date: string | Date | undefined): string {
  if (!date) return '';
  
  try {
    if (typeof date === 'string') {
      // Handle various date string formats
      const parsedDate = new Date(date);
      if (isNaN(parsedDate.getTime())) {
        return '';
      }
      return parsedDate.toISOString().split('T')[0]; // YYYY-MM-DD
    } else {
      return date.toISOString().split('T')[0];
    }
  } catch {
    return '';
  }
}

// Normalize event type to match current schema
function normalizeEventType(type: string | EventType | undefined): EventType {
  if (!type) return 'MEETING';
  
  const typeStr = type.toString().toUpperCase();
  
  // Map legacy types to current types
  const typeMapping: Record<string, EventType> = {
    'PLAN': 'PLANNING',
    'PLANNING': 'PLANNING',
    'MEET': 'MEETING',
    'MEETING': 'MEETING',
    'REVIEW': 'MONTHLY_REVIEW',
    'MONTHLY_REVIEW': 'MONTHLY_REVIEW',
    'HOLIDAY': 'HOLIDAYS',
    'HOLIDAYS': 'HOLIDAYS',
    'EVENT': 'MEETING',
    'CONFERENCE': 'MEETING',
    'CALL': 'MEETING'
  };
  
  return typeMapping[typeStr] || 'MEETING';
}

// Normalize legacy event to current schema
function normalizeLegacyEvent(legacyEvent: LegacyEvent): Event | null {
  try {
    // Extract title from various possible fields
    const title = legacyEvent.title || legacyEvent.description || 'Untitled Event';
    if (!title.trim()) return null;

    // Normalize date
    const date = normalizeDate(legacyEvent.date);
    if (!date) return null;

    // Parse time information
    let startTime = legacyEvent.startTime;
    let endTime = legacyEvent.endTime;
    
    // Handle legacy time field
    if (!startTime && legacyEvent.time) {
      const timeMatch = legacyEvent.time.match(/(\d{1,2}):(\d{2})/);
      if (timeMatch) {
        startTime = legacyEvent.time;
      }
    }
    
    // Handle duration field
    if (startTime && !endTime && legacyEvent.duration) {
      const durationMatch = legacyEvent.duration.match(/(\d+)/);
      if (durationMatch) {
        const hours = parseInt(durationMatch[1]);
        const startHour = parseInt(startTime.split(':')[0]);
        const startMin = parseInt(startTime.split(':')[1] || '0');
        const endHour = startHour + hours;
        endTime = `${endHour.toString().padStart(2, '0')}:${startMin.toString().padStart(2, '0')}`;
      }
    }

    const normalizedEvent: Event = {
      id: legacyEvent.id || '', // Will be generated by server
      title: title.trim(),
      type: normalizeEventType(legacyEvent.type || legacyEvent.eventType),
      date,
      endDate: legacyEvent.endDate ? normalizeDate(legacyEvent.endDate) : undefined,
      startTime,
      endTime,
      notes: legacyEvent.notes || legacyEvent.description,
      createdAt: '', // Will be set by server
      updatedAt: '' // Will be set by server
    };

    // Validate against schema
    const validationResult = insertEventSchema.safeParse({
      title: normalizedEvent.title,
      type: normalizedEvent.type,
      date: normalizedEvent.date,
      endDate: normalizedEvent.endDate,
      startTime: normalizedEvent.startTime,
      endTime: normalizedEvent.endTime,
      notes: normalizedEvent.notes
    });

    if (!validationResult.success) {
      console.warn('Event failed validation:', normalizedEvent, validationResult.error);
      return null;
    }

    return normalizedEvent;
  } catch (error) {
    console.error('Error normalizing legacy event:', error, legacyEvent);
    return null;
  }
}

// Get recovery state from localStorage
function getRecoveryState(): RecoveryState {
  try {
    const state = localStorage.getItem(RECOVERY_STATE_KEY);
    if (state) {
      return JSON.parse(state);
    }
  } catch (error) {
    console.warn('Failed to read recovery state:', error);
  }
  
  return {
    lastRunDate: '',
    importedFingerprints: [],
    completedSources: []
  };
}

// Save recovery state to localStorage
function saveRecoveryState(state: RecoveryState): void {
  try {
    localStorage.setItem(RECOVERY_STATE_KEY, JSON.stringify(state));
  } catch (error) {
    console.warn('Failed to save recovery state:', error);
  }
}

// Check if source was already completed
function isSourceCompleted(source: string): boolean {
  const state = getRecoveryState();
  return state.completedSources.includes(source);
}

// Mark source as completed
function markSourceCompleted(source: string): void {
  const state = getRecoveryState();
  if (!state.completedSources.includes(source)) {
    state.completedSources.push(source);
    saveRecoveryState(state);
  }
}

// Check if event was already imported
function isEventImported(fingerprint: string): boolean {
  const state = getRecoveryState();
  return state.importedFingerprints.includes(fingerprint);
}

// Mark event as imported
function markEventImported(fingerprint: string): void {
  const state = getRecoveryState();
  if (!state.importedFingerprints.includes(fingerprint)) {
    state.importedFingerprints.push(fingerprint);
    saveRecoveryState(state);
  }
}

// Recover data from a specific IndexedDB database
async function recoverFromIndexedDB(dbName: string): Promise<LegacyEvent[]> {
  if (isSourceCompleted(`indexeddb-${dbName}`)) {
    console.log(`Skipping already completed IndexedDB source: ${dbName}`);
    return [];
  }

  try {
    console.log(`Checking IndexedDB: ${dbName}`);
    const db = await openDB<CalendarDB>(dbName, 1);
    const events = await db.getAll('events');
    console.log(`Found ${events.length} events in IndexedDB: ${dbName}`);
    
    if (events.length > 0) {
      markSourceCompleted(`indexeddb-${dbName}`);
    }
    
    return events;
  } catch (error) {
    console.log(`No data in IndexedDB ${dbName}:`, error);
    return [];
  }
}

// Recover data from localStorage
async function recoverFromLocalStorage(): Promise<LegacyEvent[]> {
  const allEvents: LegacyEvent[] = [];
  
  for (const key of LOCALSTORAGE_KEYS) {
    if (isSourceCompleted(`localstorage-${key}`)) {
      console.log(`Skipping already completed localStorage source: ${key}`);
      continue;
    }

    try {
      const data = localStorage.getItem(key);
      if (data) {
        console.log(`Checking localStorage key: ${key}`);
        const parsed = JSON.parse(data);
        
        let events: LegacyEvent[] = [];
        if (Array.isArray(parsed)) {
          events = parsed;
        } else if (parsed.events && Array.isArray(parsed.events)) {
          events = parsed.events;
        } else if (typeof parsed === 'object' && parsed.title) {
          events = [parsed];
        }
        
        if (events.length > 0) {
          console.log(`Found ${events.length} events in localStorage: ${key}`);
          allEvents.push(...events);
          markSourceCompleted(`localstorage-${key}`);
        }
      }
    } catch (error) {
      console.log(`Error reading localStorage ${key}:`, error);
    }
  }
  
  return allEvents;
}

// Main recovery function with progress reporting
export async function performDataRecovery(
  progressCallback?: (progress: RecoveryProgress) => void
): Promise<{ success: boolean; migratedCount: number; duplicatesSkipped: number; errors: string[] }> {
  
  const progress: RecoveryProgress = {
    stage: 'scanning',
    found: 0,
    processed: 0,
    imported: 0,
    duplicates: 0,
    errors: []
  };

  const updateProgress = () => {
    if (progressCallback) {
      progressCallback({ ...progress });
    }
  };

  try {
    updateProgress();

    // Step 1: Scan all data sources
    console.log('üîç Scanning for recoverable data...');
    
    const allLegacyEvents: LegacyEvent[] = [];
    
    // Check all IndexedDB databases
    for (const dbName of INDEXEDDB_NAMES) {
      const events = await recoverFromIndexedDB(dbName);
      allLegacyEvents.push(...events);
    }
    
    // Check localStorage
    const localStorageEvents = await recoverFromLocalStorage();
    allLegacyEvents.push(...localStorageEvents);
    
    progress.found = allLegacyEvents.length;
    progress.stage = 'normalizing';
    updateProgress();

    if (allLegacyEvents.length === 0) {
      progress.stage = 'complete';
      updateProgress();
      return { 
        success: true, 
        migratedCount: 0, 
        duplicatesSkipped: 0, 
        errors: ['No data found to recover'] 
      };
    }

    console.log(`üìã Found ${allLegacyEvents.length} total events, normalizing...`);

    // Step 2: Normalize and validate events
    const normalizedEvents: Event[] = [];
    const seenFingerprints = new Set<string>();
    
    for (const legacyEvent of allLegacyEvents) {
      progress.processed++;
      updateProgress();

      const normalizedEvent = normalizeLegacyEvent(legacyEvent);
      if (!normalizedEvent) {
        progress.errors.push(`Failed to normalize event: ${legacyEvent.title || 'Unknown'}`);
        continue;
      }

      // Check for duplicates
      const fingerprint = createEventFingerprint(normalizedEvent);
      
      if (seenFingerprints.has(fingerprint) || isEventImported(fingerprint)) {
        progress.duplicates++;
        updateProgress();
        console.log(`‚è≠Ô∏è  Skipping duplicate: ${normalizedEvent.title}`);
        continue;
      }

      seenFingerprints.add(fingerprint);
      normalizedEvents.push(normalizedEvent);
    }

    progress.stage = 'importing';
    updateProgress();

    console.log(`üì§ Importing ${normalizedEvents.length} unique events...`);

    // Step 3: Import to database
    let importedCount = 0;
    
    for (const event of normalizedEvents) {
      try {
        const { id, createdAt, updatedAt, ...eventData } = event;
        
        const response = await apiRequest('POST', '/api/events', eventData);
        
        if (response.ok) {
          importedCount++;
          progress.imported = importedCount;
          
          // Mark as imported
          const fingerprint = createEventFingerprint(event);
          markEventImported(fingerprint);
          
          console.log(`‚úÖ Imported: ${event.title}`);
        } else {
          const errorText = await response.text();
          progress.errors.push(`Failed to import "${event.title}": ${errorText}`);
        }
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        progress.errors.push(`Error importing "${event.title}": ${errorMsg}`);
      }
      
      updateProgress();
    }

    // Update recovery state
    const state = getRecoveryState();
    state.lastRunDate = new Date().toISOString();
    saveRecoveryState(state);

    progress.stage = 'complete';
    updateProgress();

    console.log(`üéâ Recovery complete! Imported ${importedCount} events, skipped ${progress.duplicates} duplicates`);

    return {
      success: true,
      migratedCount: importedCount,
      duplicatesSkipped: progress.duplicates,
      errors: progress.errors
    };

  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    progress.stage = 'error';
    progress.errors.push(`Recovery failed: ${errorMsg}`);
    updateProgress();
    
    console.error('‚ùå Recovery failed:', error);
    
    return {
      success: false,
      migratedCount: progress.imported,
      duplicatesSkipped: progress.duplicates,
      errors: progress.errors
    };
  }
}

// Legacy exports for backward compatibility
export async function recoverIndexedDBData(): Promise<Event[]> {
  console.warn('recoverIndexedDBData is deprecated, use performDataRecovery instead');
  const result = await performDataRecovery();
  return []; // Can't return meaningful data with old interface
}

export async function migrateEventsToDatabase(events: Event[]): Promise<void> {
  console.warn('migrateEventsToDatabase is deprecated, use performDataRecovery instead');
  // Legacy function kept for compatibility but does nothing
}

// Utility to reset recovery state (for testing)
export function resetRecoveryState(): void {
  localStorage.removeItem(RECOVERY_STATE_KEY);
  console.log('üîÑ Recovery state reset');
}

// Utility to get recovery statistics
export function getRecoveryStats(): RecoveryState & { totalSources: number } {
  const state = getRecoveryState();
  return {
    ...state,
    totalSources: INDEXEDDB_NAMES.length + LOCALSTORAGE_KEYS.length
  };
}